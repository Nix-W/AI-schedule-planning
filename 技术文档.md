# AI 个人日程规划项目 - 技术文档

> 文档版本：v1.0  
> 更新日期：2026-01-23  
> 作者：[Nix]

---

## 一、项目结构

```
ai-calendar/
├── src/
│   ├── app/
│   │   ├── api/
│   │   │   └── parse-event/
│   │   │       └── route.ts        # 解析 API
│   │   ├── layout.tsx              # 根布局
│   │   ├── page.tsx                # 首页
│   │   └── globals.css             # 全局样式
│   ├── components/
│   │   ├── Calendar.tsx            # 日历组件
│   │   ├── EventInput.tsx          # 输入框组件
│   │   ├── EventModal.tsx          # 事件详情弹窗
│   │   ├── EventPreview.tsx        # 解析预览组件
│   │   └── QuickTemplates.tsx      # 快捷模板组件
│   ├── lib/
│   │   ├── parse-event.ts          # AI 解析逻辑
│   │   ├── storage.ts              # 本地存储
│   │   ├── conflict.ts             # 冲突检测
│   │   └── utils.ts                # 工具函数
│   └── types/
│       └── calendar.ts             # 类型定义
├── package.json
├── tsconfig.json
├── tailwind.config.js
└── README.md
```

---

## 二、类型定义

### 2.1 核心类型 (`src/types/calendar.ts`)

```typescript
// ============================================
// 日历事件
// ============================================

export interface CalendarEvent {
  id: string;
  title: string;
  start: Date;
  end: Date;
  isAllDay: boolean;
  location?: string;
  description?: string;
  attendees?: string[];
  color?: string;
  type?: EventType;
  recurrence?: RecurrenceRule;
  createdAt: Date;
  updatedAt: Date;
}

export type EventType = 
  | "meeting"      // 会议 - 蓝色
  | "task"         // 任务 - 绿色
  | "reminder"     // 提醒 - 黄色
  | "personal"     // 个人 - 紫色
  | "other";       // 其他 - 灰色

export const EVENT_COLORS: Record<EventType, string> = {
  meeting: "#3b82f6",   // blue-500
  task: "#22c55e",      // green-500
  reminder: "#eab308",  // yellow-500
  personal: "#a855f7",  // purple-500
  other: "#6b7280",     // gray-500
};

// ============================================
// 重复规则 (RFC 5545 iCalendar)
// ============================================

export interface RecurrenceRule {
  freq: "daily" | "weekly" | "monthly" | "yearly";
  interval: number;
  byDay?: WeekDay[];
  byMonthDay?: number;
  until?: Date;
  count?: number;
}

export type WeekDay = "MO" | "TU" | "WE" | "TH" | "FR" | "SA" | "SU";

// ============================================
// API 请求/响应
// ============================================

export interface ParseEventRequest {
  text: string;
  timezone?: string;
  referenceTime?: string;
  preferences?: UserPreferences;
}

export interface UserPreferences {
  defaultDuration?: number;        // 默认时长（分钟）
  workingHours?: {
    start: string;                 // "09:00"
    end: string;                   // "18:00"
  };
  weekStartsOn?: 0 | 1;            // 0=周日, 1=周一
}

export interface ParseEventResponse {
  success: true;
  data: ParsedEventData;
}

export interface ParsedEventData {
  id: string;
  title: string;
  start: string;                   // ISO 8601
  end: string;                     // ISO 8601
  isAllDay: boolean;
  location?: string;
  description?: string;
  attendees?: string[];
  type?: EventType;
  recurrence?: RecurrenceRule;
  meta: ParseMeta;
}

export interface ParseMeta {
  confidence: number;              // 0-1
  rawInput: string;
  parsedAt: string;
  warnings?: string[];
}

export interface ParseEventError {
  success: false;
  error: {
    code: "PARSE_FAILED" | "INVALID_INPUT" | "API_ERROR";
    message: string;
    suggestions?: string[];
  };
}

export type ParseEventResult = ParseEventResponse | ParseEventError;

// ============================================
// 组件 Props
// ============================================

export interface EventInputProps {
  onEventParsed: (event: ParsedEventData) => void;
  disabled?: boolean;
}

export interface EventModalProps {
  event: CalendarEvent | null;
  onClose: () => void;
  onDelete: (id: string) => void;
  onEdit: (event: CalendarEvent) => void;
}

export interface EventPreviewProps {
  data: ParsedEventData;
  onConfirm: () => void;
  onCancel: () => void;
  onEdit: (data: ParsedEventData) => void;
}
```

---

## 三、API 接口文档

### 3.1 解析日程接口

**POST** `/api/parse-event`

#### 请求

```typescript
// Headers
Content-Type: application/json

// Body
{
  "text": "明天下午3点和老王在星巴克讨论项目",
  "timezone": "Asia/Shanghai",        // 可选，默认 Asia/Shanghai
  "referenceTime": "2026-01-23T10:00:00+08:00"  // 可选，用于测试
}
```

#### 成功响应 (200)

```json
{
  "success": true,
  "data": {
    "id": "evt_a1b2c3d4",
    "title": "和老王讨论项目",
    "start": "2026-01-24T15:00:00+08:00",
    "end": "2026-01-24T16:00:00+08:00",
    "isAllDay": false,
    "location": "星巴克",
    "attendees": ["老王"],
    "type": "meeting",
    "meta": {
      "confidence": 0.95,
      "rawInput": "明天下午3点和老王在星巴克讨论项目",
      "parsedAt": "2026-01-23T10:30:00+08:00"
    }
  }
}
```

#### 失败响应 (400/500)

```json
{
  "success": false,
  "error": {
    "code": "PARSE_FAILED",
    "message": "无法解析时间信息",
    "suggestions": [
      "请添加具体时间，如「下午3点」",
      "请添加具体日期，如「明天」「下周一」"
    ]
  }
}
```

#### 错误码说明

| code | HTTP Status | 说明 |
|------|-------------|------|
| INVALID_INPUT | 400 | 输入为空或格式错误 |
| PARSE_FAILED | 200 | AI 无法解析，返回建议 |
| API_ERROR | 500 | Claude API 调用失败 |

---

## 四、后端实现

### 4.1 AI 解析模块 (`src/lib/parse-event.ts`)

```typescript
import Anthropic from "@anthropic-ai/sdk";

const client = new Anthropic();

// ============================================
// System Prompt
// ============================================

const buildSystemPrompt = (timezone: string, referenceTime: Date) => {
  const weekdays = ["日", "一", "二", "三", "四", "五", "六"];
  
  return `你是一个专业的日程解析助手。将用户的自然语言描述精确转换为结构化的日历事件。

## 当前上下文
- 当前时间：${referenceTime.toISOString()}
- 用户时区：${timezone}
- 今天是：${referenceTime.toLocaleDateString("zh-CN", {
    year: "numeric",
    month: "long",
    day: "numeric"
  })}（星期${weekdays[referenceTime.getDay()]}）

## 时间解析规则

### 相对日期
| 表达 | 规则 |
|------|------|
| 今天 | ${referenceTime.toISOString().split("T")[0]} |
| 明天 | 当前日期 + 1天 |
| 后天 | 当前日期 + 2天 |
| 下周X | 下一个自然周的周X（周一为首日） |
| 这周X | 本周的周X |
| X天后 | 当前日期 + X天 |
| 下个月X号 | 下月X号 |

### 时间点
| 表达 | 默认时间 |
|------|----------|
| 早上/上午 | 09:00 |
| 中午 | 12:00 |
| 下午 | 14:00 |
| 晚上 | 19:00 |
| X点 | X:00（1-6点默认下午，7-12点根据上下文） |
| X点半 | X:30 |

### 持续时间
- 未指定时长：默认 60 分钟
- "半小时"：30 分钟
- "一个小时"：60 分钟
- "全天" / "一整天"：设置 isAllDay: true

### 事件类型推断
| 关键词 | 类型 |
|--------|------|
| 会议、开会、讨论、评审 | meeting |
| 任务、完成、提交、做 | task |
| 提醒、记得、别忘了 | reminder |
| 约会、聚餐、看电影、健身 | personal |
| 其他 | other |

### 重复规则
| 表达 | 解析 |
|------|------|
| 每天 | freq: daily |
| 每周X | freq: weekly, byDay: [X] |
| 每两周 | freq: weekly, interval: 2 |
| 工作日 | freq: weekly, byDay: [MO,TU,WE,TH,FR] |
| 每月X号 | freq: monthly, byMonthDay: X |

## 输出要求
1. 时间使用 ISO 8601 格式，包含时区偏移（${timezone}）
2. title 简洁明了，提取核心事项
3. confidence: 0.9+ 确定，0.7-0.9 中等，<0.7 模糊
4. 有歧义时在 warnings 中说明`;
};

// ============================================
// Tool Definition
// ============================================

const calendarEventTool = {
  name: "create_calendar_event",
  description: "创建结构化的日历事件",
  input_schema: {
    type: "object" as const,
    properties: {
      title: {
        type: "string",
        description: "事件标题，简洁描述核心事项"
      },
      start: {
        type: "string",
        description: "开始时间，ISO 8601 格式含时区"
      },
      end: {
        type: "string",
        description: "结束时间，ISO 8601 格式含时区"
      },
      isAllDay: {
        type: "boolean",
        description: "是否全天事件"
      },
      location: {
        type: "string",
        description: "地点（如有提及）"
      },
      attendees: {
        type: "array",
        items: { type: "string" },
        description: "参与者列表（如有提及）"
      },
      type: {
        type: "string",
        enum: ["meeting", "task", "reminder", "personal", "other"],
        description: "事件类型"
      },
      recurrence: {
        type: "object",
        properties: {
          freq: {
            type: "string",
            enum: ["daily", "weekly", "monthly", "yearly"]
          },
          interval: { type: "number" },
          byDay: {
            type: "array",
            items: { type: "string" }
          },
          byMonthDay: { type: "number" },
          until: { type: "string" },
          count: { type: "number" }
        },
        description: "重复规则（如有）"
      },
      confidence: {
        type: "number",
        description: "解析置信度 0-1"
      },
      warnings: {
        type: "array",
        items: { type: "string" },
        description: "解析过程中的警告或歧义说明"
      }
    },
    required: ["title", "start", "end", "isAllDay", "type", "confidence"]
  }
};

// ============================================
// Parse Function
// ============================================

export async function parseEvent(
  text: string,
  timezone = "Asia/Shanghai",
  referenceTime?: string
) {
  const refTime = referenceTime ? new Date(referenceTime) : new Date();
  const systemPrompt = buildSystemPrompt(timezone, refTime);

  const response = await client.messages.create({
    model: "claude-sonnet-4-20250514",
    max_tokens: 1024,
    system: systemPrompt,
    tools: [calendarEventTool],
    tool_choice: { type: "tool", name: "create_calendar_event" },
    messages: [
      {
        role: "user",
        content: text
      }
    ]
  });

  const toolUse = response.content.find(block => block.type === "tool_use");

  if (!toolUse || toolUse.type !== "tool_use") {
    throw new Error("AI 未能解析日程");
  }

  return toolUse.input;
}
```

### 4.2 API 路由 (`src/app/api/parse-event/route.ts`)

```typescript
import { parseEvent } from "@/lib/parse-event";
import { NextRequest } from "next/server";
import { ParseEventRequest } from "@/types/calendar";

export async function POST(request: NextRequest) {
  try {
    const body: ParseEventRequest = await request.json();
    const { text, timezone, referenceTime } = body;

    // 输入校验
    if (!text?.trim()) {
      return Response.json({
        success: false,
        error: {
          code: "INVALID_INPUT",
          message: "请输入日程描述"
        }
      }, { status: 400 });
    }

    // 调用 AI 解析
    const parsed = await parseEvent(text, timezone, referenceTime);

    // 构造响应
    return Response.json({
      success: true,
      data: {
        id: `evt_${crypto.randomUUID().slice(0, 8)}`,
        ...parsed,
        meta: {
          confidence: parsed.confidence,
          rawInput: text,
          parsedAt: new Date().toISOString(),
          warnings: parsed.warnings
        }
      }
    });

  } catch (error) {
    console.error("Parse event error:", error);
    
    return Response.json({
      success: false,
      error: {
        code: "API_ERROR",
        message: "服务暂时不可用，请稍后重试"
      }
    }, { status: 500 });
  }
}
```

---

## 五、前端组件

### 5.1 日历组件 (`src/components/Calendar.tsx`)

```typescript
"use client";

import { Calendar, dateFnsLocalizer, Views } from "react-big-calendar";
import { format, parse, startOfWeek, getDay } from "date-fns";
import { zhCN } from "date-fns/locale";
import "react-big-calendar/lib/css/react-big-calendar.css";
import { CalendarEvent, EVENT_COLORS } from "@/types/calendar";

const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek: () => startOfWeek(new Date(), { weekStartsOn: 1 }),
  getDay,
  locales: { "zh-CN": zhCN }
});

interface Props {
  events: CalendarEvent[];
  onSelectEvent?: (event: CalendarEvent) => void;
  onSelectSlot?: (slotInfo: { start: Date; end: Date }) => void;
}

export function CalendarView({ events, onSelectEvent, onSelectSlot }: Props) {
  // 根据事件类型设置颜色
  const eventStyleGetter = (event: CalendarEvent) => ({
    style: {
      backgroundColor: event.color || EVENT_COLORS[event.type || "other"],
      borderRadius: "4px",
      opacity: 0.9,
      color: "white",
      border: "none",
      display: "block"
    }
  });

  return (
    <Calendar
      localizer={localizer}
      events={events}
      startAccessor="start"
      endAccessor="end"
      style={{ height: "100%" }}
      views={[Views.MONTH, Views.WEEK, Views.DAY]}
      defaultView={Views.WEEK}
      selectable
      onSelectEvent={onSelectEvent}
      onSelectSlot={onSelectSlot}
      eventPropGetter={eventStyleGetter}
      messages={{
        today: "今天",
        previous: "上一页",
        next: "下一页",
        month: "月",
        week: "周",
        day: "日",
        agenda: "日程",
        date: "日期",
        time: "时间",
        event: "事件",
        noEventsInRange: "暂无日程"
      }}
    />
  );
}
```

### 5.2 输入框组件 (`src/components/EventInput.tsx`)

```typescript
"use client";

import { useState } from "react";
import { EventInputProps, ParsedEventData, ParseEventResult } from "@/types/calendar";

export function EventInput({ onEventParsed, disabled }: EventInputProps) {
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async () => {
    const trimmed = input.trim();
    if (!trimmed || disabled) return;

    setLoading(true);
    setError("");

    try {
      const res = await fetch("/api/parse-event", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: trimmed })
      });

      const data: ParseEventResult = await res.json();

      if (data.success) {
        onEventParsed(data.data);
        setInput("");
      } else {
        setError(data.error.message);
      }
    } catch (e) {
      setError("网络错误，请重试");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <div className="flex gap-2">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && handleSubmit()}
          placeholder="输入日程，如：明天下午3点和老王开会"
          disabled={loading || disabled}
          className="flex-1 px-4 py-3 border border-gray-300 rounded-lg 
                     focus:outline-none focus:ring-2 focus:ring-blue-500 
                     focus:border-transparent disabled:bg-gray-100"
        />
        <button
          onClick={handleSubmit}
          disabled={loading || !input.trim() || disabled}
          className="px-6 py-3 bg-blue-500 text-white rounded-lg font-medium
                     hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed
                     transition-colors"
        >
          {loading ? (
            <span className="flex items-center gap-2">
              <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" 
                        stroke="currentColor" strokeWidth="4" fill="none" />
                <path className="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
              </svg>
              解析中
            </span>
          ) : "添加"}
        </button>
      </div>
      {error && (
        <p className="text-red-500 text-sm">{error}</p>
      )}
    </div>
  );
}
```

### 5.3 解析预览组件 (`src/components/EventPreview.tsx`)

```typescript
"use client";

import { EventPreviewProps, EVENT_COLORS } from "@/types/calendar";

export function EventPreview({ data, onConfirm, onCancel, onEdit }: EventPreviewProps) {
  const startDate = new Date(data.start);
  const endDate = new Date(data.end);
  const isLowConfidence = data.meta.confidence < 0.7;
  const color = EVENT_COLORS[data.type || "other"];

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-xl p-6 w-[480px] max-w-[90vw] shadow-xl">
        {/* 标题 */}
        <div className="flex items-center gap-3 mb-4">
          <div 
            className="w-4 h-4 rounded-full" 
            style={{ backgroundColor: color }}
          />
          <h2 className="text-xl font-semibold">{data.title}</h2>
        </div>

        {/* 置信度警告 */}
        {isLowConfidence && (
          <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <p className="text-yellow-800 text-sm font-medium">
              ⚠️ 解析可能不准确
            </p>
            {data.meta.warnings && (
              <ul className="mt-1 text-yellow-700 text-sm">
                {data.meta.warnings.map((w, i) => (
                  <li key={i}>• {w}</li>
                ))}
              </ul>
            )}
          </div>
        )}

        {/* 详情 */}
        <div className="space-y-3 text-gray-600 mb-6">
          <div className="flex gap-2">
            <span className="text-gray-400 w-16">时间</span>
            <span>
              {data.isAllDay ? (
                `${startDate.toLocaleDateString("zh-CN")} 全天`
              ) : (
                `${startDate.toLocaleString("zh-CN")} - ${endDate.toLocaleTimeString("zh-CN")}`
              )}
            </span>
          </div>

          {data.location && (
            <div className="flex gap-2">
              <span className="text-gray-400 w-16">地点</span>
              <span>{data.location}</span>
            </div>
          )}

          {data.attendees && data.attendees.length > 0 && (
            <div className="flex gap-2">
              <span className="text-gray-400 w-16">参与者</span>
              <span>{data.attendees.join("、")}</span>
            </div>
          )}

          {data.recurrence && (
            <div className="flex gap-2">
              <span className="text-gray-400 w-16">重复</span>
              <span>{formatRecurrence(data.recurrence)}</span>
            </div>
          )}
        </div>

        {/* 操作按钮 */}
        <div className="flex gap-3 justify-end">
          <button
            onClick={onCancel}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          >
            取消
          </button>
          <button
            onClick={() => onEdit(data)}
            className="px-4 py-2 text-blue-600 hover:bg-blue-50 rounded-lg"
          >
            编辑
          </button>
          <button
            onClick={onConfirm}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
          >
            确认添加
          </button>
        </div>
      </div>
    </div>
  );
}

function formatRecurrence(rule: any): string {
  const freqMap: Record<string, string> = {
    daily: "每天",
    weekly: "每周",
    monthly: "每月",
    yearly: "每年"
  };
  
  let text = freqMap[rule.freq] || "";
  
  if (rule.interval > 1) {
    text = `每${rule.interval}${text.slice(1)}`;
  }
  
  if (rule.byDay) {
    const dayMap: Record<string, string> = {
      MO: "一", TU: "二", WE: "三", TH: "四", FR: "五", SA: "六", SU: "日"
    };
    text += `（周${rule.byDay.map((d: string) => dayMap[d]).join("、")}）`;
  }
  
  return text;
}
```

---

## 六、工具函数

### 6.1 本地存储 (`src/lib/storage.ts`)

```typescript
import { CalendarEvent } from "@/types/calendar";

const STORAGE_KEY = "ai_calendar_events";

export function saveEvents(events: CalendarEvent[]): void {
  const serialized = events.map(e => ({
    ...e,
    start: e.start.toISOString(),
    end: e.end.toISOString(),
    createdAt: e.createdAt.toISOString(),
    updatedAt: e.updatedAt.toISOString(),
    recurrence: e.recurrence ? {
      ...e.recurrence,
      until: e.recurrence.until?.toISOString()
    } : undefined
  }));
  
  localStorage.setItem(STORAGE_KEY, JSON.stringify(serialized));
}

export function loadEvents(): CalendarEvent[] {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return [];

  try {
    const data = JSON.parse(raw);
    return data.map((e: any) => ({
      ...e,
      start: new Date(e.start),
      end: new Date(e.end),
      createdAt: new Date(e.createdAt),
      updatedAt: new Date(e.updatedAt),
      recurrence: e.recurrence ? {
        ...e.recurrence,
        until: e.recurrence.until ? new Date(e.recurrence.until) : undefined
      } : undefined
    }));
  } catch {
    return [];
  }
}

export function clearEvents(): void {
  localStorage.removeItem(STORAGE_KEY);
}
```

### 6.2 冲突检测 (`src/lib/conflict.ts`)

```typescript
import { CalendarEvent } from "@/types/calendar";

export interface ConflictResult {
  hasConflict: boolean;
  conflicts: CalendarEvent[];
}

export function checkConflict(
  newEvent: { start: Date; end: Date },
  existingEvents: CalendarEvent[]
): ConflictResult {
  const conflicts = existingEvents.filter(event => {
    // 全天事件不参与时间冲突检测
    if (event.isAllDay) return false;
    
    // 检查时间重叠
    return (
      newEvent.start < event.end && 
      newEvent.end > event.start
    );
  });

  return {
    hasConflict: conflicts.length > 0,
    conflicts
  };
}

export function formatConflictMessage(conflicts: CalendarEvent[]): string {
  if (conflicts.length === 0) return "";
  
  if (conflicts.length === 1) {
    return `与「${conflicts[0].title}」时间冲突`;
  }
  
  return `与 ${conflicts.length} 个日程时间冲突`;
}
```

---

## 七、环境配置

### 7.1 环境变量 (`.env.local`)

```bash
# Claude API Key
ANTHROPIC_API_KEY=sk-ant-xxxxx

# 可选：自定义配置
DEFAULT_TIMEZONE=Asia/Shanghai
DEFAULT_EVENT_DURATION=60
```

### 7.2 依赖清单 (`package.json`)

```json
{
  "name": "ai-calendar",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-big-calendar": "^1.8.0",
    "date-fns": "^3.0.0",
    "@anthropic-ai/sdk": "^0.20.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-big-calendar": "^1.8.0",
    "tailwindcss": "^3.4.0",
    "postcss": "^8.0.0",
    "autoprefixer": "^10.0.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.0"
  }
}
```

---

## 八、测试

### 8.1 API 测试用例

```bash
# 测试 1: 基础日程
curl -X POST http://localhost:3000/api/parse-event \
  -H "Content-Type: application/json" \
  -d '{"text": "明天下午3点开会"}'

# 测试 2: 带地点和参与者
curl -X POST http://localhost:3000/api/parse-event \
  -H "Content-Type: application/json" \
  -d '{"text": "下周三和老王在星巴克讨论项目"}'

# 测试 3: 重复日程
curl -X POST http://localhost:3000/api/parse-event \
  -H "Content-Type: application/json" \
  -d '{"text": "每周一早上9点站会，30分钟"}'

# 测试 4: 全天事件
curl -X POST http://localhost:3000/api/parse-event \
  -H "Content-Type: application/json" \
  -d '{"text": "1月30号全天休假"}'

# 测试 5: 模糊输入
curl -X POST http://localhost:3000/api/parse-event \
  -H "Content-Type: application/json" \
  -d '{"text": "找时间和老王聊聊"}'
```

### 8.2 期望输出

| 用例 | 期望 title | 期望 start | 期望 confidence |
|------|------------|------------|-----------------|
| 1 | 开会 | 明天 15:00 | > 0.9 |
| 2 | 和老王讨论项目 | 下周三 12:00 | > 0.8 |
| 3 | 站会 | 下周一 09:00 + recurrence | > 0.9 |
| 4 | 休假 | 01-30 全天 | > 0.9 |
| 5 | 和老王聊聊 | - | < 0.7 + warnings |

---

## 九、部署

### 9.1 Vercel 部署

```bash
# 安装 Vercel CLI
npm i -g vercel

# 部署
vercel

# 设置环境变量
vercel env add ANTHROPIC_API_KEY
```

### 9.2 注意事项

1. 确保 `ANTHROPIC_API_KEY` 已配置
2. API 路由会自动部署为 Serverless Functions
3. 注意 Claude API 的调用限制和费用

---

## 附录：快速启动命令

```bash
# 1. 创建项目
npx create-next-app@latest ai-calendar --typescript --tailwind --eslint --app

# 2. 进入目录
cd ai-calendar

# 3. 安装依赖
npm install react-big-calendar date-fns @anthropic-ai/sdk
npm install -D @types/react-big-calendar

# 4. 配置环境变量
echo "ANTHROPIC_API_KEY=your-key-here" > .env.local

# 5. 启动开发服务器
npm run dev
```
